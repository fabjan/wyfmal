(load-file      "lib/load-file-once.mal")
(load-file-once "lib/more-core.mal")
(load-file-once "lib/trivial.mal")

;; Tracing can be useful when testing programs.

(def! *tracing* (atom false))

(defn! set-tracing! [b]
    (reset! *tracing* b))

(defn! trace [& args]
    (if (deref *tracing*)
        (apply println "TRACE" args)))

;; We will read code from standard input,
;; mal only provides the readline function so
;; we define some wrappers around it.

(def! *stdin* (atom nil))

(defn! peekc []
    (do
        (if (nil? (first (deref *stdin*)))
            (let* [line (readline "")]
                (if (not (nil? line))
                    (reset! *stdin* (seq (str line "\n"))))))
        (first (deref *stdin*))))

(defn! getc []
    (let* [c (peekc)]
        (do (swap! *stdin* rest) c)))

;; There shall be a get-next function
;; to get the next word.

(defn! get-next []
    (do
        (drop-space)
        (slurp-word)))

;; get-next needs some helpers.

(defn! drop-space []
    (if (space? (peekc))
        (do (getc) (drop-space))))

(defn! slurp-word [] (slurp-word- []))
(defn! slurp-word- [acc]
    (cond
        (nil? (peekc))   (apply str acc)
        (space? (peekc)) (apply str acc)
        :else            (slurp-word- (conj acc (getc)))))

(defn! space? [c]
    (or (= " " c)
        (= "\n" c)))

;; Now we need a stack ...

(def! *stack* (atom (list)))

(defn! push! [x]
    (do
        (trace "push" x)
        (swap! *stack* (partial cons x))))

(defn! pop! []
    (let* [top (first (deref *stack*))]
        (do
            (trace "pop" top)
            (swap! *stack* rest)
            top)))

;; ... and a dictionary ...

(def! *dict* (atom {}))

(defmcr! defword! [name body]
    `(swap! *dict* (fn* [d] (assoc d ~name (fn* [] ~body)))))

(defn! recall [w]
    (get (deref *dict*) w))

;; ... with some builtins

(defword! "+"
          (let* [a (pop!) b (pop!)] (push! (+ a b))))

(defword! "print"
          (println (pop!)))

;; We're gonna need some more helpers for reading numbers.

(defn! digit? [c]
    (apply or (map (partial = c) (seq "0123456789"))))

(defn! numeric? [s]
    (let* [chars (seq s)]
        (if (nil? chars)
            false
            (apply and
                   (or (digit? (first chars)) (= "-" (first chars)))
                   (map digit? (rest chars))))))

(defn! number [x]
    (cond
        (number? x) x
        (string? x) (read-string x)))

;; We can now run the program:
;;     42 4711 + print

;; Up next is branching, and for jumping around we need memory ...

(def! *memory* (atom []))

(defn! in-mem? [p]
    (< p (count (deref *memory*))))

(defn! read-mem [p]
    (nth (deref *memory*) p))

(defn! write-mem! [p v]
    (swap! *memory* (partial with-nth p v)))

;; ... and a program counter ...

(def! *next* (atom 0))

(defn! jump! [addr]
    (do
        (trace "jump to" addr)
        (if (in-mem? addr)
            (reset! *next* addr)
            (throw-str "cannot jump to" skip))))

(defn! skip! [skip]
    (jump! (+ (deref *next*) (number skip))))

(defn! next-word! []
    (if (in-mem? (deref *next*))
        (read-next!)))

(defn! read-next! []
    (do
        (trace "memory read from" (deref *next*))
        (let* [w (read-mem (deref *next*))]
            (do
                (swap! *next* inc)
                w))))

(defn! write-next! [w]
    (do
        (trace "memory write" w "to" (deref *next*))
        (write-mem! (deref *next*) w)
        (swap! *next* inc)
        w))

;; ... and the program in memory.

(defn! slurp-prog! []
    (let* [w (get-next)]
        (if (not (or (nil? w) (= "" w)))
            (do
                (write-next! w)
                (slurp-prog!)))))

;; Okay I think we can do branches now!

(defword! "branch"
          (skip! (next-word!)))

(defword! "branch?"
          (if (zero? (pop!))
              (swap! *next* inc)
              (skip! (dec (number (next-word!))))))

;; .. and I think we need dup to make effective use of branch?

(defword! "dup"
          (let* [a (pop!)]
              (do (push! a) (push! a))))

;; We can now run the program:
;;     -3 1 + dup dup print branch? -6

;; Let's allow forth programs to turn on or off tracing.

(defword! "trace"
          (set-tracing! true))

(defword! "notrace"
          (set-tracing! false))

;; Compiling is a different mode from interpreting,
;; so we have to tell those apart.

(def! *mode* (atom ""))

(defn! set-mode! [new-mode]
    (do
        (trace "mode is now" new-mode)
        (reset! *mode* new-mode)))

(defn! start-compiling! []
    (let* [w (next-word!)]
        (cond
            (nil? w)     (throw-str "cannot compile nothing")
            (numeric? w) (throw-str "can't compile a number")
            :otherwise   (do
                             (remember-addr! w (deref *next*))
                             (set-mode! "compile")))))

(defn! remember-addr! [w addr]
    (swap! *dict* (fn* [d] (assoc d w addr))))

;; For calling words we need to be able to return,
;; a stack can track this state.

(def! *return-stack* (atom (list)))

(defn! rpush! [x]
    (do
        (trace "rpush" x)
        (swap! *return-stack* (partial cons x))))

(defn! rpop! []
    (let* [top (first (deref *return-stack*))]
        (do
            (trace "rpop" top)
            (swap! *return-stack* rest)
            top)))

(defn! call! [w]
    (let* [x (recall w)]
        (cond
            (fn? x)     (apply x)
            (number? x) (do (rpush! (deref *next*)) (jump! x))
            :otherwise  (throw-str "cannot call" w "(" x " in dict)"))))

;; More arithmetic.

(defword! "-"
          (let* [a (pop!) b (pop!)] (push! (- b a))))

(defword! "*"
          (let* [a (pop!) b (pop!)] (push! (* a b))))

(defword! "/"
          (let* [a (pop!) b (pop!)] (push! (/ b a))))

;; We can now run the program:
;;     : ++ 1 + ;
;;     : square dup * ;
;;     : cube square square ;
;;     : half 2 / ;
;;     6 cube 7 * 19 square + half 5 - print

;; Go forth!

(defn! forth []
    (cond
        (= (deref *mode*) "interpret") (interpret)
        (= (deref *mode*) "compile")   (compile)
        (= (deref *mode*) "stop")      (trace "kthxbye")))

(defn! interpret []
    (let* [w (next-word!)]
        (do
            (trace "interpreting" w)
            (if (nil? w)
                (set-mode! "stop")
                (cond
                    (recall w)   (call! w)
                    (numeric? w) (push! (number w))
                    (= ":" w)    (start-compiling!)
                    (= ";" w)    (jump! (rpop!))
                    :otherwise   (throw-str "unknown word '" w "'")))
            (forth))))

(defn! compile []
    (let* [w (next-word!)]
        (do
            (if (nil? w)
                (set-mode! "stop")
                (cond
                    (recall w)   (trace "compiling" w)
                    (numeric? w) (trace "compiling" w)
                    (= ";" w)    (set-mode! "interpret")
                    :otherwise   (throw-str "unknown word '" w "'")))
            (forth))))

(slurp-prog!)
(reset! *next* 0)
(set-mode! "interpret")
(forth)
