(load-file      "lib/load-file-once.mal")
(load-file-once "lib/more-core.mal")

;; We will read code from standard input,
;; mal only provides the readline function so
;; we define some wrappers around it.

(def! *stdin* (atom nil))

(defn! peekc []
    (do
        (if (nil? (first (deref *stdin*)))
            (let* [line (readline "")]
                (if (not (nil? line))
                    (reset! *stdin* (seq (str line "\n"))))))
        (first (deref *stdin*))))

(defn! getc []
    (let* [c (peekc)]
        (do (swap! *stdin* rest) c)))

;; There shall be a get-next function
;; to get the next word.

(defn! get-next []
    (do
        (drop-space)
        (slurp-word)))

;; get-next needs some helpers.

(defn! drop-space []
    (if (space? (peekc))
        (do (getc) (drop-space))))

(defn! slurp-word [] (slurp-word- []))
(defn! slurp-word- [acc]
    (cond
        (nil? (peekc))   (apply str acc)
        (space? (peekc)) (apply str acc)
        :else            (slurp-word- (conj acc (getc)))))

(defn! space? [c]
    (or (= " " c)
        (= "\n" c)))

;; Now we need a stack ...

(def! *stack* (atom (list)))

(defn! push! [x]
    (swap! *stack* (partial cons x)))

(defn! pop! []
    (let* [top (first (deref *stack*))]
        (do (swap! *stack* rest) top)))

;; ... and a dictionary ...

(def! *dict* (atom {}))

(defmcr! defword! [name body]
    `(swap! *dict* (fn* [d] (assoc d ~name (fn* [] ~body)))))

(defn! recall [w]
    (get (deref *dict*) w))

;; ... with some builtins

(defword! "+"
          (let* [a (pop!) b (pop!)] (push! (+ a b))))

(defword! "print"
          (println (pop!)))

;; We're gonna need some more helpers for reading numbers.

(defn! digit? [c]
    (apply or (map (partial = c) (seq "0123456789"))))

(defn! numeric? [s]
    (let* [chars (seq s)]
        (if (nil? chars)
            false
            (apply and (map digit? chars)))))

(defn! number [s]
    (read-string s))

;; Go forth!

(defn! forth []
    (let* [w (get-next)]
        (if (not (= "" w))
            (do
                (cond
                    (recall w)   (apply (recall w))
                    (numeric? w) (push! (number w))
                    :otherwise   (throw (str "unknown word '" w "'")))
                (forth)))))

(forth)
