(load-file      "lib/load-file-once.mal")
(load-file-once "lib/more-core.mal")
(load-file-once "lib/trivial.mal")

;; Tracing can be useful when testing programs.

(def! *tracing* (atom false))

(defn! set-tracing! [b]
    (reset! *tracing* b))

(defn! trace [& args]
    (if (deref *tracing*)
        (apply println "TRACE" args)))

;; We will read code from standard input,
;; mal only provides the readline function so
;; we define some wrappers around it.

(def! *stdin* (atom nil))

(defn! peekc []
    (do
        (if (nil? (first (deref *stdin*)))
            (let* [line (readline "")]
                (if (not (nil? line))
                    (reset! *stdin* (seq (str line "\n"))))))
        (first (deref *stdin*))))

(defn! getc []
    (let* [c (peekc)]
        (do (swap! *stdin* rest) c)))

;; There shall be a get-next function
;; to get the next word.

(defn! get-next []
    (do
        (drop-space)
        (slurp-word)))

;; get-next needs some helpers.

(defn! drop-space []
    (if (space? (peekc))
        (do (getc) (drop-space))))

(defn! slurp-word [] (slurp-word- []))
(defn! slurp-word- [acc]
    (cond
        (nil? (peekc))   (apply str acc)
        (space? (peekc)) (apply str acc)
        :else            (slurp-word- (conj acc (getc)))))

(defn! space? [c]
    (or (= " " c)
        (= "\n" c)))

;; Now we need a stack ...

(def! *stack* (atom (list)))

(defn! push! [x]
    (do
        (trace "push" x)
        (swap! *stack* (partial cons x))))

(defn! pop! []
    (let* [top (first (deref *stack*))]
        (do
            (trace "pop" top)
            (swap! *stack* rest)
            top)))

;; ... and a dictionary ...

(def! *dict* (atom {}))

(defmcr! defword! [name body]
    `(swap! *dict* (fn* [d] (assoc d ~name (fn* [] ~body)))))

(defn! recall [w]
    (get (deref *dict*) w))

;; ... with some builtins

(defword! "+"
          (let* [a (pop!) b (pop!)] (push! (+ a b))))

(defword! "print"
          (println (pop!)))

;; We're gonna need some more helpers for reading numbers.

(defn! digit? [c]
    (apply or (map (partial = c) (seq "0123456789"))))

(defn! numeric? [s]
    (let* [chars (seq s)]
        (if (nil? chars)
            false
            (apply and
                   (or (digit? (first chars)) (= "-" (first chars)))
                   (map digit? (rest chars))))))

(defn! number [x]
    (cond
        (number? x) x
        (string? x) (read-string x)))

;; We can now run the program:
;;     42 4711 + print

;; Up next is branching, and for jumping around we need memory ...

(def! *memory* (atom []))

(defn! in-mem? [p]
    (< p (count (deref *memory*))))

(defn! read-mem [p]
    (nth (deref *memory*) p))

(defn! write-mem! [p v]
    (swap! *memory* (partial with-nth p v)))

;; ... and a program counter ...

(def! *next* (atom 0))

(defn! jump! [addr]
    (do
        (trace "jump to" addr)
        (if (in-mem? addr)
            (reset! *next* addr)
            (throw (str "cannot jump to" skip)))))

(defn! skip! [skip]
    (jump! (+ (deref *next*) (number skip))))

(defn! next-word! []
    (if (in-mem? (deref *next*))
        (read-next!)))

(defn! read-next! []
    (do
        (trace "memory read from" (deref *next*))
        (let* [w (read-mem (deref *next*))]
            (do
                (swap! *next* inc)
                w))))

(defn! write-next! [w]
    (do
        (trace "memory write" w "to" (deref *next*))
        (write-mem! (deref *next*) w)
        (swap! *next* inc)
        w))

;; ... and the program in memory.

(defn! slurp-prog! []
    (let* [w (get-next)]
        (if (not (or (nil? w) (= "" w)))
            (do
                (write-next! w)
                (slurp-prog!)))))

;; Okay I think we can do branches now!

(defword! "branch"
          (skip! (next-word!)))

(defword! "branch?"
          (if (zero? (pop!))
              (swap! *next* inc)
              (skip! (dec (number (next-word!))))))

;; .. and I think we need dup to make effective use of branch?

(defword! "dup"
          (let* [a (pop!)]
              (do (push! a) (push! a))))

;; We can now run the program:
;;     -3 1 + dup dup print branch? -6

;; Let's allow forth programs to turn on or off tracing.

(defword! "trace"
          (set-tracing! true))

(defword! "notrace"
          (set-tracing! false))

;; Go forth!

(defn! forth []
    (let* [w (next-word!)]
        (if (not (nil? w))
            (do
                (cond
                    (recall w)   (apply (recall w))
                    (numeric? w) (push! (number w))
                    :otherwise   (throw (str "unknown word '" w "'")))
                (forth)))))

(slurp-prog!)
(reset! *next* 0)
(forth)
